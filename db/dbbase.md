**本地管理表空间和字典管理表空间**

第一、字典管理表空间

将Oracle的区管理信息存放在表空间的字典中进行管理，所有区的分配与释放，都会使字典的记录的增减变动。也就是在字典的记录中会执行更新、插入、删 除操作，在执行上述操作时，都会生成重做日志，对字典的管理，将影响正常操作的效率，并且在区分配、回收的过程中，产生磁盘碎片，如果磁盘碎片增加到一定 的程度，会浪费空间，严重影响效率,同时，Oracle 在管理表空间的管理中，会产生递归SQL。<br/>
如果要用字典的方式管理表空间，可以在创建表空间时，使用： EXTENT MANAGEMENT DICTIONARY 选项。<br/>

第二、本地管理表空间 

本地管理是以位图的方式，将区的分配信息保存在数据文件本身，所有区的分配等操作都只是位图的运算，位图中的每一位对应数据文件中的一个区或几个连续的区，这样在进行区管理时，生成的重做日志将非常少，并且运行的效率很高。并且产生磁盘碎片很少。<br/>
如果要用本地管理表空间，可以在创建表空间时，使用： EXTENT MANAGEMENT LOCAL 选项。
在表空间的管理中，Oracle8I中可以采用字典管理，也可以采用本地管理，如果不指定，将采用字典管理方式。<br/>
  在 Oracle9I中，推荐采用本地管理的方式，如果不指定，将采用本地管理的方式。<br/>
  从Oracle 10g开如，要求采用本地管理的方式。<br/>
**自定义变量**

sql中自定义变量的格式为：declare @变量名 变量数据类型，之后每次使用时必须带@

**视图**

- ①　从一个或几个基本表中根据用户需要而做成一个虚表
- ②　视图是虚表,它在存储时只存储视图的定义,而没有存储对应的数据
- ③　视图只在刚刚打开的一瞬间,通过定义从基表中搜集数据,并展现给用户

**索引：**

1)在下面两条select语句中:<br/>

   select * from table1  where  field1<=10000 and field1>=0;<br/>
   select * from table1  where  field1>=0 and field1<=10000;<br/>

   如果数据表中的数据field1都>=0,则第一条select语句要比第二条select语句效率高的多，因为第二条select语句的第一个条件耗费了大量的系统资源。<br/>
   第一个原则：在where子句中应把最具限制性的条件放在最前面。<br/>
 
(2)在下面的select语句中:<br/>

   select * from tab  where  a=… and b=… and c=…;<br/>

  若有索引index(a,b,c)，则where子句中字段的顺序应和索引中字段顺序一致。<br/>
   第二个原则：where子句中字段的顺序应和索引中字段顺序一致。<br/>
 
以下假设在field1上有唯一索引I1，在field2上有非唯一索引I2。<br/>

(3) 
select field3,field4 from tb where field1='sdf'        快<br/>
    select * from tb where field1='sdf'      慢，<br/>
因为后者在索引扫描后要多一步ROWID表访问。<br/>
 
(4) 
select field3,field4 from tb where field1>='sdf'        快<br/>
select field3,field4 from tb where field1>'sdf'        慢<br/>
因为前者可以迅速定位索引。<br/>
 
(5) select field3,field4 from tb where field2 like 'R%'    快<br/>
select field3,field4 from tb where field2 like '%R'    慢，<br/>
因为后者不使用索引。<br/>
 
(6) 使用函数如：<br/>
select field3,field4 from tb where upper(field2)='RMN'不使用索引。<br/>
如果一个表有两万条记录，建议不使用函数；如果一个表有五万条以上记录，严格禁止使用函数！两万条记录以下没有限制。<br/>
 
(7) 空值不在索引中存储，所以<br/>
    select field3,field4 from tb where field2 is[not] null不使用索引。<br/>
 
(8) 不等式如<br/>
    select field3,field4 from tb where field2!='TOM'不使用索引。<br/>
    相似地，<br/>
    select field3,field4 from tb where field2 not in('M','P')不使用索引。<br/>
 
(9) 多列索引，只有当查询中索引首列被用于条件时，索引才能被使用。<br/>
 
(10)  MAX，MIN等函数，如<br/>
Select max(field2) from tb使用索引。所以，如果需要对字段取max，min，sum等，应该加索引。
一次只使用一个聚集函数，如：<br/>
select “min”=min(field1), “max”=max(field1)  from tb      
不如：select “min”=(select min(field1) from tb) , “max”=(select max(field1) from tb)    
 
(11) 重复值过多的索引不会被查询优化器使用。而且因为建了索引，修改该字段值时还要修改索引，所以更新该字段的操作比没有索引更慢。<br/>
 
(12) 索引值过大（如在一个char(40)的字段上建索引），会造成大量的I/O开销（甚至会超过表扫描的I/O开销）。因此，尽量使用整数索引。 Sp_estspace可以计算表和索引的开销。<br/>
 
(13) 对于多列索引，order by的顺序必须和索引的字段顺序一致。<br/>
 
(14) 在sybase中，如果order by的字段组成一个簇索引，那么无须做order by。记录的排列顺序是与簇索引一致的。<br/>


**标准的 SQL 的解析顺序为:** 

- (1).FROM 子句, 组装来自不同数据源的数据
-  (2).WHERE 子句, 基于指定的条件对记录进行筛选
-  (3).GROUP BY 子句, 将数据划分为多个分组 
- (4).使用聚合函数进行计算
-  (5).使用 HAVING 子句筛选分组
-  (6).计算Select所有的表达式 
- (7).使用 ORDER BY 对结果集进行排序


**连接分为内链接、左外连接、右外连接（INNER JOIN、LEFT JOIN、RIGHT JOIN）;**

- 内链接：取两个表的交集，仅显示符合连接条件的记录；
- 左外连接：显示左表的全部记录及右表符合连接条件的记录；
- 右外连接：显示右表的全部记录及左表符合连接条件的记录。


内连接返回的结果集是两个表中所有相匹配的数据，不包含没有匹配的行。<br/>
外连接有三种：左外连接，右外连接，全外连接。外连接不仅包含符合连接条件的行，还包含左表（左外连接）、右表（右外连接）或两个表（全外连接）中的所有数据行。对于没有匹配的行就用NULL值来填充。<br/>



**完整性**

- 实体完整性指表中行的完整性
- 域完整性指列的值域的完整性，如数据类型、格式、值域范围、是否允许空值等等
- 参照完整性基于外键与被引用主键之间的关系，确保键值在所有表中的一致性


**存储过程**

1. 存储过程允许标准组件式编程存储过程创建后可以在程序中被多次调用执行，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，但对应用程序源代码却毫无影响，从而极大的提高了程序的可移植性。<br/>
2. 存储过程能够实现较快的执行速度如果某一操作包含大量的T-SQL语句代码，分别被多次执行，那么存储过程要比批处理的执行速度快得多。因为存储过程是预编译的，在首次运行一个存储过程时，查询优化器对其进行分析、优化并给出最终被存在系统表中的存储计划。而批处理的T-SQL语句每次运行都需要预编译和优化，所以速度就要慢一些。<br/>
3. 存储过程减轻网络流量对于同一个针对数据库对象的操作，如果这一操作所涉及到的T-SQL语句被组织成一存储过程，那么当在客户机上调用该存储过程时，网络中传递的只是该调用语句，否则将会是多条SQL语句。从而减轻了网络流量，降低了网络负载。<br/>
4. 存储过程可被作为一种安全机制来充分利用系统管理员可以对执行的某一个存储过程进行权限限制，从而能够实现对某些数据访问的限制，避免非授权用户对数据的访问，保证数据的安全。<br/>

**3NF**

- 1NF:原子性 字段不可再分,否则就不是关系数据库; 
- 2NF:唯一性 一个表只说明一个事物; 
- 3NF:每列都与主键有直接关系，不存在传递依赖;


**char()与varchar()的区分，什么情况下用char()**？

char的长度是不可变的，而varchar的长度是可变的，也就是说，定义一个char[10]和varchar[10],如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的<br/>


**数据完整性**

- 1、实体完整性，实体完整性的目的是确保数据库中所有实体的唯一性，也就是不应出现完全相同的数据记录。

- 2、区域完整性，匹配完整性要求数据表中的数据位于某一个特定的允许范围内。

- 3、参考完整性，是用来维护相关数据表之间数据一致性的手段，通过实现参考完整性，可以避免因一个数据表的记录改变而造成另一个数据表内的数据变成无效值。

- 4、用户自定义完整性，用户自定义由用户根据实际应用中的需要自行定义。

如果两个表中存储的信息相互关联，那么只要修改了一个表，另外一个表也要做出相应的修改，则称该这两个表中的数据具备完整性

**触发程序**

- A、 触发程序与表相关，当对表执行INSERT、DELETE或UPDATE语句时，将激活触发程序。可以将
触发程序设置为在执行语句之前或之后激活。例如，可以在从表中删除每一行之前，或在更新了
要想创建触发程序或舍弃触发程序，可使用CREATE TRIGGER或DROP TRIGGER语句

- B、触发程序不能调用将数据返回客户端的存储程序，也不能使用采用CALL语句的动态SQL
（允许存储程序通过参数将数据返回触发程序）。

- C、使用OLD和NEW关键字，能够访问受触发程序影响的行中的列（OLD和NEW不区分大小写）。
 在INSERT触发程序中，仅能使用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用
 OLD.col_name，没有新行。在UPDATE触发程序中，可以使用OLD.col_name来引用更新前的某一
 行的列，也能使用NEW.col_name来引用更新后的行中的列。
 
- D、 触发程序不能使用以显式或隐式方式开始或结束事务的语句，如START TRANSACTION、
 COMMIT或ROLLBACK。



**删除表的语句为：DROP TABLE table_name**;


而DELETE和TRUNCATE TABLE都是删除表中的数据的语句，它们的不同之处在于：<br/>

- 1、TRUNCATE TABLE比DELETE的速度快；<br/>
- 2、TRUNCATE TABLE 是删除表的所有行，而DELETE是删除表的一行或者多行（除非DELETE不带WHERE语句）；<br/>
- 3、在删除时如果遇到任何一行违反约束（主要是外键约束），TRUNCATE TABLE仍然删除，只是表的结构及其列、约束、索引等保持不变，但DELETE是直接返回错误；<br/>
- 4、对于被外键约束的表，不能使用TRUNCATE TABLE，而应该使用不带WHERE语句的DELETE语句。<br/>
- 5、如果想保留标识计数值，要用DELETE，因为TRUNCATE TABLE会对新行标志符列搜用的计数值重置为该列的种子。<br/>

**索引**

- 1、表的主键、外键必须有索引；
- 2、数据量超过300的表应该有索引；
- 3、经常与其他表进行连接的表，在连接字段上应该建立索引；
- 4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
- 5、索引应该建在选择性高的字段上；
- 6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
- 7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
- A、正确选择复合索引中的主列字段，一般是选择性较好的字段；
- B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
- C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
- D、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
- E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
- 8、频繁进行数据操作的表，不要建立太多的索引；
- 9、删除无用的索引，避免对执行计划造成负面影响；

**聚集索引**：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。

 聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。

**非聚集索引**：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。

非聚集索引中的项目按索引键值的顺序存储，而表中的信息按另一种顺序存储（这可以由聚集索引规定）。对于非聚集索引，可以为在表非聚集索引中查找数据时常用的每个列创建一个非聚集索引。有些书籍包含多个索引。例如，一本介绍园艺的书可能会包含一个植物通俗名称索引，和一个植物学名索引，因为这是读者查找信息的两种最常用的方法。

**数据库中有可能会存在不一致的数据**。

造成数据不一致的原因主要有：<br/>
数据冗余<br/>
如果数据库中存在冗余数据，比如两张表中都存储了用户的地址，在用户的地址发生改变时，如果只更新了一张表中的数据，那么这两张表中就有了不一致的数据。<br/>
并发控制不当<br/>
比如某个订票系统中，两个用户在同一时间订同一张票，如果并发控制不当，可能会导致一张票被两个用户预订的情况。当然这也与元数据的设计有关。<br/>
故障和错误<br/>
如果软硬件发生故障造成数据丢失等情况，也可能引起数据不一致的情况。因此我们需要提供数据库维护和数据恢复的一些措施。<br/>


**视图包含下列结构是不可以更新的**

- 1：集合运算符 union，union all, intersect，minus 
- 2：distinct关键字 
- 3：group by,order by,connect by,或者start with 
- 4：子查询 
- 5：分组函数 
- 6：需要更新的列不是视图定义的 
- 7：具有连接查询(可以更新键值保存表的数据) 
- 8：违反基表的约束条件；连接视图是指基于多表连接查询创建的视图（一般不容易修改，但通用instead of触发器可以实现修改的功能）

**SQL**

找出表ppp里面num最小的数，不能使用min函数。
 
	```
	Select top 1 num from ppp order by num;
	  Select * from ppp where num <= all(select num from ppp);
	```

 选择表ppp2中num重复的记录
  
	```
	Select num from ppp2 group by num having (count (num)>1);
	```


拷贝表和四表联查的SQL语句。
 
	```
	复制表：(只复制结构)
	  Select * into B from A where 1=0;
	  拷贝表：（复制数据）
	  Select * into B from A;
	```

  
数据库备份：
  
  	`mysqldump -uroot -h127.0.0.1 -p123456 test.sql > sql.bak`
