
**1. 什么是 Java 虚拟机？为什么 Java 被称作是 “ 平台无关的编程语言 ” ？**

Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。 Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。 
Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。 
Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

**2.JDK 和 JRE 的区别是什么**？

JDK:   java 开发工具包 , 包含了 JRE 、编译器和其它工具（如： javaDOc 、 java 调试器 )
JRE:  java 运行环境 , 包含 java 虚拟机和 java 程序所需的核心类库。 
如果只是想跑 java 程序，那么只需安装 JRE ，如果要写 java 程序并且运行，那就需要 JDK 了。

**3."static" 关键字是什么意思？ Java 中是否可以覆盖一个 private 或者是 static 的方法？**

如果一个类的变量或者方法前面有 static 修饰，那么表明这个方法或者变量属于这个类，也就是说可以在不创建对象的情况下直接使用 
当父类的方法被 private 修饰时，表明该方法为父类私有，对其他任何类都是不可见的，因此如果子类定了一个与父类一样的方法，这对于子类来说相当于是一个新的私有方法，且如果要进行向上转型，然后去调用该 “ 覆盖方法 ” ，会产生编译错误

class Parent {
    private fun() {
        ...
    }   
}
class Child extends Parent {
    private fun() {
        ...
    }
}
class Test {
    public static void main(String[] args) {
        Parent c = new Child();
        c.fun(); //编译出错
    }
}
static 方法时编译时静态绑定的，属于类，而覆盖是运行时动态绑定的 ( 动态绑定的多态 ), 因此不能覆盖 .

**4.Java 支持的基本数据类型有哪些？什么是自动拆装箱？**

java 支持的基本数据类型有以下 9 种 :byte,shot,int,long,float,double,char,boolean,void.
自动拆装箱是 java 从 jdk1.5 引用，目的是将原始类型自动的装换为相对应的对象，也可以逆向进行，即拆箱。这也体现 java 中一切皆对象的宗旨。 
所谓自动装箱就是将原始类型自动的转换为对应的对象，而拆箱就是将对象类型转换为基本类型。 java 中的自动拆装箱通常发生在变量赋值的过程中，如：

    Integer object = 3; //自动装箱
    int o = object; //拆箱
在 java 中，应该注意自动拆装箱，因为有时可能因为 java 自动装箱机制，而导致创建了许多对象，对于内存小的平台会造成压力。

**5. 覆盖和重载是什么 ?**

覆盖 也叫 重写 ，发生在子类与父类之间，表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。 
重载 是指在一个类中，可以有多个相同名称的方法，但是他们的参数列表的个数或类型不同，当调用该方法时，根据传递的参数类型调用对应参数列表的方法。当参数列表相同但返回值不同时，将会出现编译错误，这并不是重载，因为 jvm 无法根据返回值类型来判断应该调用哪个方法。


方法的重写（override）两同两小一大原则：
- 方法名相同，参数类型相同
- 子类返回类型小于等于父类方法返回类型，
- 子类抛出异常小于等于父类方法抛出异常，
- 子类访问权限大于等于父类方法访问权限


**6.Java 支持多继承么？如果不支持，如何实现 ?**

在 java 中是单继承的，也就是说一个类只能继承一个父类。 
java 中实现多继承有两种方式 , 一是接口，而是内部类 .

//实现多个接口 如果两个接口的变量相同 那么在调用该变量的时候 编译出错
interface interface1 {
    static String field = "dd";
    public void fun1();
    }
interface interface2 {
static String field = "dddd";
    public void fun2();
    }
class child implements interface1,interface2 {
    static String field = "dddd";
    @Override
    public void fun2() {
    }
 
    @Override
    public void fun1() {
    }   
}
 
//内部类 间接多继承
class Child {
class Father {
    private void strong() {
        System.out.println("父类");
    }
}
class Mother {
    public void getCute() {
        System.out.println("母亲");
    }
}
public void getStrong() {
    Father f = new Father();
    f.strong();
    }
public void getCute() {
    Mother m = new Mother();
    m.getCute();
    }
}

**7. 什么是值传递和引用传递？ java 中是值传递还是引用传递，还是都有 ?**

值传递   就是在方法调用的时候，实参是将自己的一份拷贝赋给形参，在方法内，对该参数值的修改不影响原来实参，常见的例子就是刚开始学习 c 语言的时候那个交换方法的例子了。 
引用传递   是在方法调用的时候，实参将自己的地址传递给形参，此时方法内对该参数值的改变，就是对该实参的实际操作。 
在 java 中只有一种传递方式，那就是 值传递 . 可能比较让人迷惑的就是 java 中的对象传递时，对形参的改变依然会意向到该对象的内容。 下面这个例子来说明 java 中是值传递 .

    public class Test {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer("hello ");
        getString(sb);
        System.out.println(sb);
    }
    public static void getString(StringBuffer s) {
        //s = new StringBuffer("ha");
        s.append("world");
    }
}
在上面这个例子中 , 当前输出结果为 :hello world 。这并没有什么问题，可能就是大家平常所理解的引用传递，那么当然会改变 StringBuffer 的内容。但是如果把上面的注释去掉，那么就会输出 :hello. 此时 sb 的值并没有变成 ha hello. 假如说是引用传递的话，那么形参的 s 也就是 sb 的地址，此时在方法里 new StringBuffer （），并将该对象赋给 s ，也就是说 s 现在指向了这个新创建的对象 . 按照引用传递的说法，此时对 s 的改变就是对 sb 的操作，也就是说 sb 应该也指向新创建的对象，那么输出的结果应该为 ha world. 但实际上输出的仅是 hello. 这说明 sb 指向的还是原来的对象，而形参 s 指向的才是创建的对象 , 这也就验证了 java 中的对象传递也是值传递。

**8. 接口和抽象类的区别是什么 ?**

 不同点在于：

- 1.    接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。

- 2.    类可以实现很多个接口，但是只能继承一个抽象类

- 3.    类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。

- 4.    抽象类可以在不提供接口方法实现的情况下实现接口。

- 5.    Java 接口中声明的变量默认都是 final 的。抽象类可以包含非 final 的变量。

- 6.    Java 接口中的成员函数默认是 public 的。抽象类的成员函数可以是 private ， protected 或者是 public 。

- 7.    接口是绝对抽象的，不可以被实例化 (java 8 已支持在接口中实现默认的方法 ) 。抽象类也不可以被实例化，但是，如果它包含 main 方法的话是可以被调用的。


9. 构造器（ constructor ）是否可被重写（ override ） ?

构造方法是不能被子类重写的，但是构造方法可以重载，也就是说一个类可以有多个构造方法。

10.Math.round(11.5) 等于多少 ? Math.round(-11.5) 等于多少 ?

Math.round(11.5)==12 Math.round(-11.5)==-11 round 方法返回与参数 最接近的长整数，参数加 1/2 后求其 floor.

**11. String, StringBuffer StringBuilder 的区别。**

String 的长度是不可变的；

StringBuffer 的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用 StringBuffer ，如果最后需要 >String ，那么使用 StringBuffer 的 toString() 方法；线程安全；

StringBuilder 是从 JDK 5 开始，为 StringBuffer 该类补充了一个单个线程使用的等价类；通常应该优先使用 StringBuilder 类，因 > 为它支持所有相同的操作，但由于它不执行同步，所以速度更快。 使用字符串的时候要特别小心，如果对一个字符串要经常改变的话，就一定不要用 String, 否则会创建许多无用的对象出来 . 来看一下比较

    String s = "hello"+"world"+"i love you";
    StringBuffer Sb = new StringBuilder("hello").append("world").append("i love you");

这个时候 s 有多个字符串进行拼接，按理来说会有多个对象产生，但是 jvm 会对此进行一个优化，也就是说只创建了一个对象，此时它的执行速度要比 StringBuffer 拼接快 . 再看下面这个 :

    String s2 = "hello"; 
    String s3 = "world"; 
    String s4 = "i love you"; 
    String s1 = s2 + s3 + s4;

上面这种情况，就会多创建出来三个对象，造成了内存空间的浪费 .

**12.JVM 内存分哪几个区，每个区的作用是什么 ?**

**方法区**

- 1. 有时候也成为 永久代 ，在该区内很少发生垃圾回收，但是并不代表不发生 GC ，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载 
- 2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
- 3. 该区域是被线程共享的。 
- 4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

**虚拟机栈**

- 1. 虚拟机栈也就是我们平常所称的 栈内存 , 它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 
- 2. 虚拟机栈是线程私有的，它的生命周期与线程相同。 
- 3. 局部变量表里存储的是基本数据类型、 returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 
- 4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 
- 5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 . 动态链接就是将常量池中的符号引用在运行期转化为直接引用。

**本地方法栈**

本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。

**堆 **

java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

**程序计数器 **

内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

**13. 如和判断一个对象是否存活 ?( 或者 GC 对象的判定方法 )**

判断一个对象是否存活有两种方法 :

**1.引用计数法** 

所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是 “ 死对象 ”, 将会被垃圾回收 .
引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B ，对象 B 又引用者对象 A ，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

**2. 可达性算法 ( 引用链法 )**

该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。 
在 java 中可以作为 GC Roots 的对象有以下几种 :

- 虚拟机栈中引用的对象
- 
- · 方法区类静态属性引用的对象
- 
- ·方法区常量池引用的对象
- 
- · 本地方法栈 JNI 引用的对象     

虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比 不一定会被回收 。当一个对象不可达 GC Root 时，这个对象并   不会立马被回收 ，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 <br/>
如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 <br/>
如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。 GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除 " 即将回收 " 集合，等待回收。<br/>

**14. 简述 java 垃圾回收机制 ?**

在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

**15.java 中垃圾收集的方法有哪些 ?**

**1.标记 - 清除 : **

这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题： 

1- . 效率不高，标记和清除的效率都很低； 
- 2. 2. 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。

**2.复制算法 :** 

为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。但是这种方式，内存的代价太高，每次基本上都要浪费一般的内存。 
于是将该算法进行了改进，内存区域不再是按照 1 ： 1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。 (java 堆又分为新生代和老年代 )

**3.标记 - 整理 **

该算法主要是为了解决标记 - 清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 

**4.分代收集 **  

现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用 复制 算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用 标记 - 整理   或者   标记 - 清除 。

**16.java 内存模型**

java 内存模型 (JMM) 是线程间通信的控制机制 .JMM 定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（ main memory ）中，每个线程都有一个私有的本地内存（ local memory ），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。 
  
线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 

- 1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。 
- 2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。 
- 写的很好 :http://www.infoq.com/cn/articles/java-memory-model-1

**17.java 类加载过程 ?**

java 类加载需要经历一下 7 个过程： 
**加载 **

加载时类加载的第一个过程，在这个阶段，将完成一下三件事情： 
- 1. 通过一个类的全限定名获取该类的二进制流。 
- 2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 3. 在内存中生成该类的 Class 对象，作为该类的数据访问入口。

**验证** 

验证的目的是为了确保 Class 文件的字节流中的信息不回危害到虚拟机 . 在该阶段主要完成以下四钟验证 :
- 1. 文件格式验证：验证字节流是否符合 Class 文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型 .
- 2. 元数据验证 : 对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。 
- 3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。 
- 4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

**准备** 

准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。

    public static int value=123;//在准备阶段value初始值为0 。在初始化阶段才会变为123 。

**解析** 

该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

**初始化 **

初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。

**18. 简述 java 类加载机制 ?**

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。

**19. 类加载器双亲委派模型机制？**

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

**20. 什么是类加载器，类加载器有哪些 ?**

实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。 
主要有一下四种类加载器 :

1- . 启动类加载器 (Bootstrap ClassLoader) 用来加载 java 核心类库，无法被 java 程序直接引用。 
- 2. 扩展类加载器 (extensions class loader): 它用来加载 Java 的扩展库。 Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 
- 3. 系统类加载器（ system class loader ）：它根据 Java 应用的类路径（ CLASSPATH ）来加载 Java 类。一般来说， Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。 
- 4. 用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。

**21. 简述 java 内存分配与回收策率以及 Minor GC 和 Major GC**

- 1.    对象优先在堆的 Eden 区分配。
- 2.    大对象直接进入老年代 .
- 3.    长期存活的对象将直接进入老年代 .
 
当 Eden 区没有足够的空间进行分配时，虚拟机会执行一次 Minor GC.Minor Gc 通常发生在新生代的 Eden 区，在这个区的对象生存期短，往往发生 Gc 的频率较高，回收速度比较快 <br/>
;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代 GC 的时候不会触发 Minor GC, 但是通过配置，可以在 Full GC 之前进行一次 Minor GC 这样可以加快老年代的回收速度。<br/>

**22.HashMap 的工作原理是什么**

HashMap 内部是通过一个数组实现的，只是这个数组比较特殊，数组里存储的元素是一个 Entry 实体 (jdk 8 为 Node) ，这个 Entry 实体主要包含 key 、 value 以及一个指向自身的 next 指针。<br/> 

HashMap 是基于 hashing 实现的，当我们进行 put 操作时，根据传递的 key 值得到它的 hashcode ，然后再用这个 hashcode 与数组的长度进行模运算，得到一个 int 值，就是 Entry 要存储在数组的位置（下标）；<br/>

当通过 get 方法获取指定 key 的值时，会根据这个 key 算出它的 hash 值（数组下标），根据这个 hash 值获取数组下标对应的 Entry ，然后判断 Entry 里的 key ， hash 值或者通过 equals() 比较是否与要查找的相同，如果相同，返回 value ，否则的话，遍历该链表（有可能就只有一个 Entry ，此时直接返回 null ），直到找到为止，否则返回 null 。 <br/>

HashMap 之所以在每个数组元素存储的是一个链表，是为了解决 hash 冲突问题，当两个对象的 hash 值相等时，那么一个位置肯定是放不下两个值的，于是 hashmap 采用链表来解决这种冲突， hash 值相等的两个元素会形成一个链表。<br/>

**23.HashMap 与 HashTable 的区别是什么 ?**

- 1.HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap 。 Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。（在 java 8 中我查看源码发现 Hashtable 并没有继承 Dictionary, 而且里面也没有同步方法，是不是 java 8 中 Hashtable 不在同步的了？有没有人解释一下？） 

- 2. HashMap 的 key 和 value 都允许为 null ，而 Hashtable 的 key 和 value 都不允许为 null 。 HashMap 遇到 key 为 null 的时候，调用 putForNullKey 方法进行处理，而对 value 没有处理； Hashtable 遇到 null ，直接返回 NullPointerException 。 

- 3. Hashtable 是同步的，而 HashMap 是非同步的，但是我们也可以通过 Collections.synchronizedMap(hashMap), 使其实现同步。

**24.CorrentHashMap 的工作原理 ?**

jdk 1.6 版 :   ConcurrenHashMap 可以说是 HashMap 的升级版， 

- ConcurrentHashMap 是线程安全的，但是与 Hashtablea 相比，实现线程安全的方式不同。 Hashtable 是通过对 hash 表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。 
- ConcurrentHashMap 是采用分离锁的方式，它并没有对整个 hash 表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对 hash 表其他地方的访问。 

**具体实现** :ConcurrentHashMap 内部有一个 Segment<K,V> 数组 , 该 Segment 对象可以充当锁。 Segment 对象内部有一个 HashEntry<K,V> 数组，于是每个 Segment 可以守护若干个桶 (HashEntry), 每个桶又有可能是一个 HashEntry 连接起来的链表，存储发生碰撞的元素。<br/> 
每个 ConcurrentHashMap 在默认并发级下会创建包含 16 个 Segment 对象的数组，每个数组有若干个桶，当我们进行 put 方法时，通过 hash 方法对 key 进行计算，得到 hash 值，找到对应的 segment ，然后对该 segment 进行加锁，然后调用 segment 的 put 方法进行存储操作，此时其他线程就不能访问当前的 segment ，但可以访问其他的 segment 对象，不会发生阻塞等待。<br/>  
jdk 1.8 版   在 jdk 8 中， ConcurrentHashMap 不再使用 Segment 分离锁，而是采用一种乐观锁 CAS 算法来实现同步问题，但其底层还是 “ 数组 + 链表 -> 红黑树 ” 的实现。<br/> 

**25. 遍历一个 List 有哪些不同的方式？**

    List<String> strList = new ArrayList<>();
    //for-each
    for(String str:strList) {
        System.out.print(str);
    }
 
    //use iterator 尽量使用这种 更安全(fail-fast)
    Iterator<String> it = strList.iterator();
    while(it.hasNext) {
        System.out.printf(it.next());
    }
**26.fail-fast 与 fail-safe 有什么区别？**

Iterator 的 fail-fast 属性与当前的集合共同起作用，因此它不会受到集合中任何改动的影响。 Java.util 包中的所有集合类都被设计为 fail->fast 的，而 java.util.concurrent 中的集合类都为 fail-safe 的。当检测到正在遍历的集合的结构被改变时， Fail-fast 迭代器抛出 ConcurrentModificationException ，而 fail-safe 迭代器从不抛出 ConcurrentModificationException 。

**27.Array 和 ArrayList 有何区别？什么时候更适合用 Array ？**

1.    Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。

2.    Array 是指定大小的，而 ArrayList 大小是固定的

**28. 哪些集合类提供对元素的随机访问？**

ArrayList 、 HashMap 、 TreeMap 和 HashTable 类提供对元素的随机访问。

**29.HashSet 的底层实现是什么 ?**

通过看源码知道 HashSet 的实现是依赖于 HashMap 的， HashSet 的值都是存储在 HashMap 中的。在 HashSet 的构造法中会初始化一个 HashMap 对象， HashSet 不允许值重复，因此， HashSet 的值是作为 HashMap 的 key 存储在 HashMap 中的，当存储的值已经存在时返回 false 。

**30.LinkedHashMap 的实现原理 ?**

LinkedHashMap 也是基于 HashMap 实现的，不同的是它定义了一个 Entry header ，这个 header 不是放在 Table 里，它是额外独立出来的。 LinkedHashMap 通过继承 hashMap 中的 Entry, 并添加两个属性 Entry before,after, 和 header 结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。 LinkedHashMap 定义了排序模式 accessOrder ，该属性为 boolean 型变量，对于访问顺序，为 true ；对于插入顺序，则为 false 。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。

**31.LinkedList 和 ArrayList 的区别是什么 ?**

- 1.    ArrayList 是基于数组实现， LinkedList 是基于链表实现
- 
- 2.    ArrayList 在查找时速度快， LinkedList 在插入与删除时更具优势

**32. 什么是线程？进程和线程的关系是什么？**

线程可定义为进程内的一个执行单位，或者定义为进程内的一个可调度实体。 在具有多线程机制的操作系统中，处理机调度的基本单位不是进程而是线程。一个进程可以有多个线程，而且至少有一个可执行线程。 <br/>
打个比喻 : 进程好比工厂 ( 计算机 ) 里的车间，一个工厂里有多个车间 ( 进程 ) 在运转 , 每个车间里有多个工人（线程）在协同工作，这些工人就可以理解为线程。 

**线程和进程的关系 :**

- 1. 线程是进程的一个组成部分 .
- 2. 进程的多个线程都在进程地址空间活动 .
- 3. 系统资源是分配给进程的，线程需要资源时，系统从进程的资源里分配给线程 .
- 4. 处理机调度的基本单位是线程 .

**33.Thread 类中的 start() 和 run() 方法有什么区别？**

start() 方法被用来启动新创建的线程，而且 start() 内部调用了 run() 方法，这和直接调用 run() 方法的效果不一样。当你调用 run() 方法的时候，只会是在原来的线程中调用，没有新的线程启动， start() 方法才会启动新线程。



**34. 什么是线程安全 ?**

当多个线程访问某个类时，不管运行时环境采用何种调度方式或者线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为。 
线程安全的核心是 “ 正确性 ” ，也就是说当多个线程访问某个类时，能够得到预期的结果，那么就是线程安全的。

**forward/redirect**

- 1.从地址栏显示来说

forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.

- 2.从数据共享来说

 forward:转发页面和转发到的页面可以共享request里面的数据.
 redirect:不能共享数据.
 
- 3.从运用地方来说

 forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
 redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.

- 4.从效率来说

forward:高.
redirect:低.


**鲁棒性(Robust,即健壮性)**
Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。



一个java文件可以包含多个java类，但是只能包含一个public类，并且public类的类名必须与java文件名相同


**Java中JDK的各种包**

Java中JDK的各种包的作用：java.lang java.util java.awt javax.swing java.io java.net java.applet 

- java.lang:java的语言包，是一个核心包，系统自动将这个包引入到用户程序，该包中主要的类，object类，它是所有类的父类，其中定义的方法其它类都可以使用。数据类型包装类，数学类，字符串类，系统和运行时类，操作类，线程类，错误和异常处理类，过程类。System提供一个独立于具体计算机资源的编程界面，Runtime类可用于直接访问运行时资源。
- java.util:java的实用包， 实用包提供了各种实用功能的类，主要包括日期类、数据结构类和随机数类等。
-  Java的java.awt提供了绘图和图像类，主要用于编写GUI程序，包括按钮、标签等常用组件以及相应的事件类

**数据比较**

JVM中一个字节以下的整型数据会在JVM启动的时候加载进内存，除非用new Integer()显式的创建对象，否则都是同一个对象<br/>
更加祥细的说明：<br/>

如果是primitive主类型，那么比较值；如果是对象，那么比较引用地址<br/>
equals需要根据具体对象的实现来判断，在Integer里面是判断值是否相等<br/>

一般说来，如果是两个Integer类型进行=比较，就是比较两个Integer对象的地址。但是有一点需要注意的是在-128至127这个区间，如果创建Integer对象的时候<br/>

- （1）Integer i = 1; 
- （2） Integer i = Integer.valueOf(1); 

如果是这两种情况创建出来的对象，那么其实只会创建一个对象，这些对象已经缓存在一个叫做IntegerCache里面了，所以==比较是相等的。<br/>
如果不在-128至127这个区间，不管是通过什么方式创建出来的对象，==永远是false，也就是说他们的地址永远不会相等。<br/>


**Java程序的种类有**：

（a）内嵌于Web文件中，由浏览器来观看的_Applet
（b）可独立运行的 Application
（c）服务器端的 Servlets

**equals**

equals没重写时候和==一样，比较的是对象的地址，题中new 了两个对象，所以各自地址不一样，使用equals比较为false，但是string类型中的equals方法Java默认重写了，可以比较对象里的值；两个对象指向的同一个string成员变量里的值相同，所以eqauals比较也相同


- A，Vector相当于一个线程安全的List
- B，HashMap是非线程安全的，其对应的线程安全类是HashTable
- C，Arraylist是非线程安全的，其对应的线程安全类是Vector
- D，StringBuffer是线程安全的，相当于一个线程安全的StringBuilder
- E，Properties实现了Map接口，是线程安全的

**volatile**
出于运行速率的考虑，java编译器会把经常经常访问的变量放到缓存（严格讲应该是工作内存）中，读取变量则从缓存中读。但是在多线程编程中,内存中的值和缓存中的值可能会出现不一致。volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。




**- Collection**

-     -----List<br/>
-                -----LinkedList    非同步<br/>
-                 ----ArrayList      非同步，实现了可变大小的元素数组<br/>
-                 ----Vector          同步<br/>
-                       ------Stack<br/>
-                 ----Set   不允许有相同的元素<br/>

**- Map**

-     -----HashTable        同步，实现一个key--value映射的哈希表<br/>
-     -----HashMap          非同步，<br/>
-     -----WeakHashMap   改进的HashMap，实现了“弱引用”，如果一个key不被引用，则被GC回收<br/>


**final**

- final修饰的方法，不允许被子类覆盖。
- final修饰的类，不能被继承。
- final修饰的变量，不能改变值。
- 使用 final 关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。


** 虚拟机的功能 **

- （1）通过 ClassLoader 寻找和装载 class 文件
- （2）解释字节码成为指令并执行，提供 class 文件的运行环境
- （3）进行运行期间垃圾回收
- （4）提供与硬件交互的平


**Throwable的子类： **

- 1.Exception（异常） :是程序本身可以处理的异常。 
- 2.Error（错误）: 是程序无法处理的错误。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，一般不需要程序处理。
- 3.检查异常（编译器要求必须处置的异常） ：  除了Error，RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。
- 4.非检查异常(编译器不要求处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）
- 

**关键字**

 java中true ,false ,null在java中不是关键字，也不是保留字，它们只是显式常量值，但是你在程序中不能使用它们作为标识符。<br/>
其中const和goto是java的保留字。java中所有的关键字都是小写的，还有要注意true,false,null,　friendly，sizeof不是java的关键字,但是你不能把它们作为java标识符用。<br/>



**多线程一共有三种实现方式**

- 1.class A继承Thread，并重写run方法，new A().start()，就执行了线程
- 2.class A实现Runnable，实现run方法，new Thread(new A()).start()

当然以上方式run方法都是无返回值的，如果需要返回值，需要Callable接口,但是该方式是依赖于线程池的。。


**五个基本原则： **

- 单一职责原则（Single-Resposibility Principle）：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。
  
- 开放封闭原则（Open-Closed principle）：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。 

- Liskov替换原则（Liskov-Substituion Principle）：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。

- 依赖倒置原则（Dependecy-Inversion Principle）：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。

- 接口隔离原则（Interface-Segregation Principle）：使用多个小的专门的接口，而不要使用一个大的总接口
 

**成员方法和静态方法:**

成员方法又称为实例方法<br/>
静态方法又称为类方法<br/>
其次：<br/>

- a，静态方法中没有this指针
- c，可以通过类名作用域的方式调用Class::fun();
- d，在类中申请一个类对象或者参数传递一个对象或者指针都可以调用;


**基本类型**

java语言是强类型语言，支持的类型分为两类：基本类型和引用类型。<br/>
基本类型包括boolean类型和数值类型，数值类型有整数类型和浮点类型。整数类型包括：byte、short、int、long和char；浮点类型包括：float和double<br/>
引用类型包括类、接口和数组类型以及特殊的null类型。<br/>


**抽象类和接口**

- 1. 一个子类只能继承一个抽象类,但能实现多个接口
- 2. 抽象类可以有构造方法,接口没有构造方法
- 3. 抽象类可以有普通成员变量,接口没有普通成员变量
- 4. 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意,接口只能public static final(默认)
- 5. 抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法
- 6. 抽象类可以有静态方法,接口不能有静态方法
- 7. 抽象类中的方法可以是public、protected;接口方法只有public


**文件操作：**

- FileInputStream提供了对文件的字节读取；
- FileReader提供了对文件的字符读取；
- FileWriter提供了对文件的字符写入；
- File提供了对文件的基本操作，包括对删除，文件路径等操作。



- ArrayList list=new ArrayList();   这种是默认创建大小为10的数组，每次扩容大小为1.5倍
- ArrayList list=new ArrayList(20);  这种是指定数组大小的创建，没有扩充



- Collection是单列集合的顶层接口,Map是双列集合的顶层接口
- Collections是一个集合的工具类，提供了排序、查找等操作集合的一些常用方法






**Servlet的生命周期一般可以用三个方法来表示：**

- init()：仅执行一次，负责在装载Servlet时初始化Servlet对象
- service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。
- destory()：在停止并且卸载Servlet时执行，负责释放资源

初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建
基本功能：service方法是在servlet生命周期中的服务期，根据HTTP请求方法（GET、POST等），将请求分发到doGet、doPost等方法

实现：默认在HttpServlet类中实现



**Java反射机制**主要提供了以下功能： 

- 在运行时判断任意一个对象所属的类；
- 在运行时构造任意一个类的对象；
- 在运行时判断任意一个类所具有的成员变量和方法；
- 在运行时调用任意一个对象的方法；生成动态代理。

**servlet**

servlet在多线程下其本身并不是线程安全的。<br/>
如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。<br/>





**内部类**

内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a，就像int a 一样，至于静态内部类和非静态内部类new的时候有点区别，Outer.Inner a=new Outer().new Inner()（非静态，先有Outer对象才能有属性） Outer.Inner a=new Outer.Inner()要把Outer.Inner看成一部分，就像类变量一样




**Vector & ArrayList 的主要区别 **

- 1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数2。 
- 2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50%  ，这样,ArrayList就有利于节约内存空间。 

如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。

**扩展知识：**

**1. Hashtable & HashMap **

Hashtable和HashMap它们的性能方面的比较类似 Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。<br/>

**2. ArrayList & LinkedList**<br/>
ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：   <br/>
从上面的分析可知,在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间<br/>
所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； <br/>
而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止<br/>
所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。<br/>
       

-  初始化父类中的静态成员变量和静态代码块 ； 
- 初始化子类中的静态成员变量和静态代码块 ； 
-初始化父类的普通成员变量和代码块，再执行父类的构造方法；
- 初始化子类的普通成员变量和代码块，再执行子类的构造方法； 


switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。String类型是java7开始支持。




**锁**

截止JDK1.8版本,java并发框架支持锁包括读写锁自旋锁乐观锁


CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。





**SpringMVC的原理：**

SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。

DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。

实现业务操作时在service层



**三个基本元素：**

- 1. 封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 
- 2. 继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。  
- 3. 多态： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。

C++ 中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术， RTTI 技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。



**super**

子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类不带参数的构造方法。<br/>
super代表父类对应的对象，所以用super访问在子类中无法直接使用的父类成员和方法

**隐含对象**

JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：
application、page、request、response、session、exception、out、config、pageContext

**JSP动作(JSP action)**

JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：

- jsp:include-当JSP页面被请求的时候包含一个文件。
- jsp:useBean-找出或者是初始化Javabean。
- jsp:setProperty-设置JavaBean的属性。
- jsp:getProperty-获取JavaBean的属性。
- jsp:forward-把请求转发到新的页面。
- jsp:plugin-产生特定浏览器的代码。

**JSP指令**

Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在 <%@ 和 %>之间的。下面列出了不同类型的Directive：<br/>

- 包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。
- 页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。
- Taglib指令： 用来声明页面中使用的自定义的标签库。

**JSP有什么优点**

- JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。
- JSP页面可以被预编译。
- JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。
- 开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。
- 开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。

**JSP请求是如何被处理的**

浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。

**HTTP隧道**

HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。

**HTTP响应的结构**

- 状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。
- HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。
- 主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。

**GenericServlet和HttpServlet有什么区别**

GenericServlet是一个通用的协议无关的Servlet，它实现了Servlet和ServletConfig接口。继承自GenericServlet的Servlet应该要覆盖service()方法。最后，为了开发一个能用在网页上服务于使用HTTP协议请求的Servlet，你的Servlet必须要继承自HttpServlet。这里有Servlet的例子。

**Servlet的体系结构**

所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务

**分布式垃圾回收(DGC)**

DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。

**数据库连接池**

像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。<br/>

**PreparedStatement和Statement**

PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。

**驱动(Driver)**

JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。

**JDBC**

JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。

**applet安全管理器**

applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。

**applet类加载器**

当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。<br/>
当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。<br/>

**网络上加载的applet和从本地文件系统加载的applet的区别**

当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。<br/>
当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。<br/>
从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。<br/>

**不受信任的applet**

不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。

**Java applet限制条件**

主要是由于安全的原因，给applet施加了以下的限制：

- applet不能够载入类库或者定义本地方法。
- applet不能在宿主机上读写文件。
- applet不能读取特定的系统属性。
- applet不能发起网络连接，除非是跟宿主机。
- applet不能够开启宿主机上其他任何的程序。

**Applet和普通的Java应用程序**

applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。<br/>
进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。<br/>
最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。<br/>

**Applet的生命周期**

- applet可以经历下面的状态：
- Init：每次被载入的时候都会被初始化。
- Start：开始执行applet。
- Stop：结束执行applet。
- Destroy：卸载applet之前，做最后的清理工作。

**什么是Applet**

java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。

**finally代码块和finalize()方法的区别**

无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。<br/>
finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。<br/>

**Exception对象**

Exception对象会在下一个垃圾回收过程中被回收掉。

**throw和throws的区别**

throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。

**Java中Exception和Error的区别**

Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。

**异常类型**

Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。


**JVM的永久代**

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)<br/>

**串行(serial)收集器和吞吐量(throughput)收集器**

吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

**Java堆**

JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。<br/>

堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。<br/>

**HashSet和TreeSet的区别**

HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。<br/>
另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。<br/>

**Enumeration接口和Iterator接口**

Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。


**Java集合类框架的最佳实践**

根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。<br/>

有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。<br/>

为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。<br/>

使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。<br/>

编程的时候接口优于实现。<br/>

底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。<br/>


**大O符号(big-O notation)**

大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。<br/>
大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。<br/>

**Java优先级队列**

PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。

**Comparable和Comparator接口**

Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。<br/>
Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。<br/>

**ArrayList和LinkedList的区别**

ArrayList和LinkedList都实现了List接口，他们有以下的不同点：<br/>
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。<br/>

与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。<br/>

相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。<br/>

LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。<br/>
也可以参考ArrayList vs. LinkedList。

**数组(Array)和列表(ArrayList)的区别**

- Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
- Array大小是固定的，ArrayList的大小是动态变化的。
- ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
- 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。


**hashCode()和equals()方法**

Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。

**迭代器(Iterator)**

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的<br/>
remove(Object Obj)删除，可以通过迭代器的remove()方法删除。<br/>

**监视器(Monitor)内部线程同步**

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

**同步方法和同步代码块**

同步方法默认用this或者当前类class对象作为锁；<br/>
同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法；<br/>

**线程的几种可用状态**

- 1. 新建( new )：新创建了一个线程对象。
- 2. 可运行( runnable )：线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获 取 cpu 的使用权 。
- 3. 运行( running )：可运行状态( runnable )的线程获得了 cpu 时间片（ timeslice ） ，执行程序代码。
- 4. 阻塞( block )：阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice ，暂时停止运行。直到线程进入可运行( runnable )状态，才有 机会再次获得 cpu timeslice 转到运行( running )状态。阻塞的情况分三种：
- (一). 等待阻塞：运行( running )的线程执行 o . wait ()方法， JVM 会把该线程放 入等待队列( waitting queue )中。
- (二). 同步阻塞：运行( running )的线程在获取对象的同步锁时，若该同步锁 被别的线程占用，则 JVM 会把该线程放入锁池( lock pool )中。
- (三). 其他阻塞: 运行( running )的线程执行 Thread . sleep ( long ms )或 t . join ()方法，或者发出了 I / O 请求时， JVM 会把该线程置为阻塞状态。            当 sleep ()状态超时、 join ()等待线程终止或者超时、或者 I / O 处理完毕时，线程重新转入可运行( runnable )状态。
- 5. 死亡( dead )：线程 run ()、 main () 方法执行结束，或者因异常退出了 run ()方法，则该线程结束生命周期。死亡的线程不可再次复生。