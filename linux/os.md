**进程间通讯**

- 管道：速度慢，容量有限
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。
- 信号量：不能传递复杂消息，只能用来同步
- 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

**页面置换**

如果一个页面已经被修改过（即，它是“脏的”），当页面被换出时，必须将其写回磁盘，如果该页面没有被修改过（即为“干净”的），则直接丢弃就可，因为它在磁盘上的副本仍然有效，改变位有时也称为“脏位”。

分段机制就是把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元<br/>
分页机制把线性地址空间和物理地址空间分别划分为大小相同的块。这样的块称之为页。通过在线性地址空间的页与物理地址空间的页之间建立的映射，分页机制实现线性地址到物理地址的转换<br/>

**线程和进程的区别联系**：

**1，进程**：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。<br/>
**2，线程：**相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 <br/>
两者都可以提高程序的并发度，提高程序运行效率和响应时间。<br/> 
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。<br/>
**根本区别**就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： <br/>
- 1、速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 <br/>
- 2、资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 <br/>
- 3、同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内<br/>


**轮询调度算法**

轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。 <br/>
抢占式任务调度允许调度程序根据某种原则去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。抢占方式的优点是，可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是能满足对响应时间有着较严格要求的实时任务的需求。 <br/>

**软链接**

软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。<br/>
软链接文件只是其源文件的一个标记，当删除了源文件后，链接文件不能独立存在，虽然仍保留文件名，但却不能查看软链接文件的内容了。<br/>
软链接不直接使用inode号作为文件指针，而是使用文件路径名作为指针（软链接：文件名 + 数据部分-->目标文件的路径名）。软件有自己的inode，并在磁盘上有一小片空间存放路径名。因此，软链接能够跨文件系统，也可以和目录链接！ 其二，软链接可以对一个不存在的文件名进行链接，但直到这个名字对应的文件被创建后，才能打开其链接。<br/>

若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名。<br/>
若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软链接。<br/>

**虚存**

通过统一管理主辅存，给用户造成内存空间巨大的假象；只把运行程序最近一段时间内活跃的一个部分放进主存，提高了系统的吞吐量，从而充分利用了地址空间

**程序什么时候使用多线程好，什么时候单线程效率高**

- 1．耗时的操作使用线程，提高应用程序响应速度

- 2．并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求

- 3．多CPU系统中，使用线程提高CPU利用率

- 4．改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序会利于理解和修改。其他情况都使用单线程。

**进程状态转换**

在操作系统中，进程一般有三种基本状态：运行状态，就绪状态和等待状态。

- 1）就绪——执行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配了处理机后，该进程便由就绪状态变为执行状态；

- 2）执行——等待：正在执行的进程因发生某等待事件而无法执行，如进程提出输入/输出请求而变成等待外部设备传输信息的状态，进程申请资源（主存空间或外部设备）得不到满足时变成等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错等）变成等待干预状态等等； 

- 3）等待——就绪：处于等待状态的进程，在其等待的事件已经发生，如输入/输出完成，资源得到满足或错误处理完毕时，处于等待状态的进程并不马上转入执行状态，而是先转入就绪状态，然后再由系统进程调度程序在适当的时候将该进程转为执行状态；

- 4）执行——就绪：正在执行的进程，因时间片用完而被暂停执行，或在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行而被迫让出处理机时，该进程便由执行状态转变为就绪状态。


**动态重定位**

**重定位**：就是把作业地址空间中使用的逻辑地址变换为存储空间的物理地址的过程，又称为地址映射<br/>
**动态重定位**：程序在执行的过程中还可以重定位，由地址变换机构进行地址变换，有以下两种实现方式：<br/>
重定位寄存器（一般用在段页式存储中）：即基址寄存器，将指令中的有效地址与重定位寄存器中的基址相加得到访问地址，从而实现地址动态修改；
采用页表描述虚、实页面的对应关系。<br/>

**临界资源**

临界资源是指每次仅允许一个进程访问的资源。 
属于临界资源的硬件有打印机、磁带机等,软件有消息缓冲队列、变量、数组、缓冲区等。 诸进程间应采取互斥方式，实现对这种资源的共享

**内存碎片**

**内零头**是指进程在向操作系统请求内存分配时，系统满足了进程所需要的内存需求后，还额外还多分了一些内存给该进程，也就是说额外多出来的这部分内存归该进程所有，其他进程是无法访问的。<br/>
**外零头**是指内存中存在着一些空闲的内存区域，这些内存区域虽然不归任何进程所有，但是因为内存区域太小，无法满足其他进程所申请的内存大小而形成的内存零头。<br/>
**页式存储管理**是以页为单位（页面的大小由系统确定，且大小是固定的）向进程分配内存的，例如：假设内存总共有100K,分为10页，每页大小为10K。现在进程A提出申请56K内存，因为页式存储管理是以页为单位进程内存分配的，所以系统会向进程A提供6个页面，也就是60K的内存空间，那么在最后一页中进程只使用了6K，从而多出了4K的内存碎片，但是这4K的内存碎片系统已经分配给进程A了，其他进程是无法再访问这些内存区域的，这种内存碎片就是内零头。<br/>
**段式存储管理**是段（段的大小是程序逻辑确定，且大小不是固定的）为单位向进程进行内存分配的，进程申请多少内存，系统就给进程分配多少内存，这样就不会产生内零头，但是段式分配会产生外零头。<br/>


**共享设备**

系统中独占设备的数量有限，往往不能满足系统中多个进程的需要，从而成为系统的瓶颈，使许多进程因等待而阻塞。另一方面分配到独占设备的进程，在整个运行期间往往占有但不经常使用设备，使设备利用率偏低。为了克服这种缺点，人们通过共享设备来虚拟独占设备，讲独占设备改造成共享设备，从而提高设备的利用率和系统的效率，该技术威假脱机技术。所以需要用到共享设备，虚拟设备，独占设备。<br/>


**引起进程阻塞和唤醒的事件**

- 1、向系统请求共享资源失败。进程转变为阻塞状态。<br/>
- 2、等待某种操作完成。比如进程启动了I/O设备，必须等I/O操作完成后，进程才能继续。<br/>
- 3、 新数据尚未到达。对于合作的进程，如果一个进程A需要先获得另一进程B提供的数据后，才能对该数据进程处理，只要数据尚未到达，进程A只能阻塞。当进程B提供数据后，便可以去唤醒进程A。<br/>
- 4、等待新任务到达，用于特定的系统进程。它们每当完成任务后，就把自己阻塞起来，等待新任务<br/>

**内存四区**

- （1）从静态存储区域分配：
内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static变量等。
- （2）在栈上分配
在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
- （3）从堆上分配：
即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。<br/>
一个C、C++程序编译时内存分为5大存储区：堆区、栈区、全局区、文字常量区、程序代码区。



**缺页异常（缺页中断）的处理流程**

- A在内存中有空闲物理页面时，分配一物理页帧f，转第E步
- B.依据页面置换算法选择将被替换的物理页帧f，对应逻辑页q
- C.如q被修改过，则把它写回外存；
- D.修改q的页表项中驻留位置为0；
- E.将需要访问的页p装入到物理页面f
- F.修改p的页表项驻留位为1,物理页帧号为f；
- G.重新执行产生缺页的指令

**虚拟页式存储管理**

- 当用户程序要装载到内存运行时，只装入部分页面，就启动程序运行
- 进程在运行中发现有需要的代码或数据不在内存时，则向系统发出缺页异常请求
- 操作系统在处理缺页异常时，将外存中相应的页面调入内存，使得进程能继续运行


**覆盖技术**

- 目标 在较小的可用内存中运行较大的程序
- 依据程序逻辑结构，将程序划分为若干功能相对独立
- 的模块；将不会同时执行的模块共享同一块内存区域
- 必要部分（常用功能）的代码和数据常驻内存
- 可选部分（不常用功能）放在其他程序模块中,只在需要用到时装入内存
- 不存在调用关系的模块可相互覆盖，共用同一块内存区域

**覆盖与交换的比较**

在单道连续分配中，当存储空间容不下程序时，可采用覆盖方法来解决；覆盖基本思想：由于程序运行时并非各个部分都要访问，因此可以将用户空间分成一个固定区和多个覆盖区。将经常活跃的放入固定区，将那些将要用的段放入覆盖区，在需要时提前调入覆盖区，替换原有的段
覆盖技术是早期在单一连续存储管理中使用的扩大存储器容量的一种技术。

覆盖

- 只能发生在没有调用关系的模块间
- 程序员须给出模块间的逻辑覆盖结构
- 发生在运行程序的内部模块间

交换

- 以进程为单位
- 不需要模块间的逻辑覆盖结构
- 发生在内存进程间




**常见的调度算法：**

- 1.先来先服务调度算法（FCFS）:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。

- 2.短作业优先调度算法 (SPF): 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。  

- 3.最高响应比优先算法(HRN)：FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。 

- 4.基于优先数调度算法(HPF)：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业

进程调度算法使用不当会造成进程长时间等待，与死锁没有关系。造成死锁主要看产生死锁的四个必要条件

- 高级调度 （作业调度或长程调度JCB ）:后备队列 
- 中级调度 （中程调度 pcb）：就绪队列，阻塞队列， 
- 低级调度 （进程调度或短程调度  pcb）：挂起队列 or 就绪队列 or 阻塞队列

**自旋锁**

自旋锁（spinlock）是一种保护临界区最常见的技术。在同一时刻只能有一个进程获得自旋锁，其他企图获得自旋锁的任何进程将一直进行尝试（即自旋，不断地测试变量），除此以外不能做任何事情。因此没有获得自旋锁的进程在获取锁之前处于忙等（阻塞状态）。


**虚存容量**

虚存容量 = min (2^计算机位数， 内存＋外存);






**ThreadLocal**

ThreadLocal不是使用在多线程之间共享数据，使变量在每个线程中都有独立拷贝，不会出现一个线程读取变量时而被另一个线程修改的现象。

**独占设备**

多个并发进程可以访问独占设备，每次一个进程使用这个独占设备

**实时操作系统**

提供及时响应和高可靠性是实时操作系统主要特点。实时操作系统有硬实时和软实时之分，硬实时要求在规定的时间内必须完成操作，这是在操作系统设计时保证的；软实时则只要按照任务的优先级，尽可能快地完成操作即可。


**通道**

CPU正在工作，突然想到要与外设通信，于是发命令给通道，然后接着做自己的工作。 通道接到命令后，接通外设与内存，并在他们之间传递数据，等数据传递完成后，通知CPU进行处理。

**固定分区分配**

固定分区分配是提前将内存划分成多个区，区的大小可以不同，但是划分好后，个数和大小都不能发生改变。
作业到来，选择一个合适大小的区放置，但是作业长度不一，不会有太合适的区恰好满足其大小，从而会造成区空间的浪费，并且此浪费非常严重。



**用户态切换到内核态**

- a.  系统调用
- b.  异常
- c.  外围设备的中断 

比如：系统调用和外围设备的中断 
  
